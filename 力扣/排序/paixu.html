<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>

  <body>
    <script>
      var item = [1, 5, 2, 3, 4, 9, 7, 6]
      // 冒泡排序
      // for (var i = 0; i < item.length; i++) {
      //   for (var j = 0; j < item.length; j++) {
      //     if (item[i] < item[j]) {
      //       [item[i], item[j]] = [item[j], item[i]]
      //     }
      //   }
      // }
      // 选择排序  冒泡排序变种
      // function sort(arr) {
      //   var index = 0
      //   for (var i = 0; i < item.length; i++) {
      //     index = i
      //     for (var j = index + 1; j < item.length; j++) {
      //       if (item[index] < item[j]) {
      //         index = j
      //       }
      //     }
      //     [arr[index], arr[i]] = [arr[i],arr[index]]
      //   }
      // }


      // 插入排序(1)
      // function sort(arr) {
      //   var current = 0
      //   for (var i = 0; i < arr.length; i++) {
      //     current = arr[i]
      //     for (var j = i - 1; j >= 0; j--) {
      //       if (current > arr[j]) {
      //         arr[j + 1] = arr[j]
      //       } else {
      //         break;
      //       }
      //     }
      //     arr[j + 1] = current
      //   }
      // }
      // 插入排序(2)
      // function sort(arr) {
      //   var index = 0
      //   var current
      //   for (var i = 0; i < arr.length; i++) {
      //     current = arr[i]
      //     var j = i - 1
      //     while (j >= 0 && arr[j] > current) {
      //       arr[j + 1] = arr[j]
      //       j--
      //     }
      //     arr[j + 1] = current
      //   }
      // }
      // 希尔排序   (插入排序改良版)
      // function sort(arr) {
      //   var len = arr.length
      //   for (var gen = Math.floor(len / 2); gen > 0; gen = Math.floor(gen / 2)) {
      //     for (var i = gen; i < len; i++) {
      //       var current = arr[i]
      //       var j = i
      //       while (j >= 0 && current < arr[j - gen]) {
      //         arr[j] = arr[j - gen];
      //         j -= gen
      //       }
      //       arr[j] = current
      //     }
      //   }
      // }
      // 快速排序
      var quickSort = function (ary, left, right) {
        if (left >= right) {
          return ary;
        }
        var i = left,
          j = right;
        base = ary[left];
        while (i < j) {
          // 从右边起，寻找比基数小的数  为什么(j--)在前面 我的理解是保证标志位不是最值(最大值或者最小值)，再去找相应的中间位置
          while (i < j && ary[j] >= base) {
            j--;
          }
          // 从左边起，寻找比基数大的数
          while (i < j && ary[i] <= base) {
            i++
          }
          if (i < j) {
            var temp = ary[i];
            ary[i] = ary[j];
            ary[j] = temp;
          }
        }
        ary[left] = ary[i];
        ary[i] = base;
        quickSort(ary, left, i - 1);
        quickSort(ary, i + 1, right);
        return ary;
      }
      console.log(quickSort(item, 0, item.length - 1))
    </script>
  </body>

</html>