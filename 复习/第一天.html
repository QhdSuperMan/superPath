<!--
 * @Author: 吴玉荣
 * @LastEditors: 吴玉荣
 * @Date: 2022-01-28 14:42:39
 * @LastEditTime: 2022-02-15 11:50:55
 * @info: 描述
-->
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>

  <body>
    <script>
      http 1.0
      缺点 巨大的header头部， 明文传输， 巨大的cookie， 队头阻塞， 不能服务器推送给客户端
      http 1.1
      keep - alive host
      catch - construll
      http 2.0 spdy
      header头压缩， keep - alive 保持链接 server - push 二进制传输 加密传输
      http 3.0 quic
      多路复用 upd 快速握手协议

      三次握手
      客户端 syn 1 seq 100
      服务端 syn 1 seq 300 ack 101
      客户端 syn ack 301

      四次挥手
      客户端 fin ack seq X
      服务端 ack X + 1 seq z
      服务端 fin ack X seq y
      客户端 ack y seq Z

      https 请求过程
      1. 客户端跟服务端建立起tcp连接 然后申请tls 握手协议， 并附上一个随机字符串 并发送自己支持的加密算法
      2. 服务端返回自己的证书 生成随机数2 选择一个加密算法
      3. 客户端验证证书， 通过ca验证证书， 验证服务器的ip等等是否是证书上面所说的 客户端生成一个随机通过服务器公匙加密
      4. 服务端和客户端都通过3生成的串生成加密密匙

      dns
      dns有两种查询方式
      迭代查询 当前本地dns服务器不能应答客户端的请求时， 去查询根dns服务器， 跟dns服务器一般会把顶级dns服务器告诉他， 这种方式叫做
      递归查询 浏览器缓存没有dns缓存， 查询host文件有没有映射， 然后再查看本地dns解析器有没有缓存， 然后再请求本地dns服务器，
      然后本地服务器会代替客户端去请求， 本地服务器就代表递归查询

      垃圾回收机制
      1 标记清除法
      每隔一段时间把内存里面的对象打上标志 例如1， 然后把调用栈里面的对象打上0， 然后把标志还是1的内存全部删掉
      优点： 操作简单。 缺点： 不能实时释放内存, 内存碎片化， 不利于分配内存， 标记整理法
      2 引用计数法
      内存被变量引用引用计数加1， 变量不再引用， 引用计数减1， 引用变成0之后清空内存，
      优点： 可以实时释放内存 缺点 无法解决循环引用问题 还有有格外的计数器来记录

      优化
      新生代内存, 老生代内存
      新生代内存分为 使用区和休闲区， 当使用区内存满了的时候， 触发垃圾回收机制
      使用区的所有活动对象打上标， 然后会复制到休闲区， 然后清空使用区， 然后休闲区和服务区角色互换

      内存晋升
      1 经过多次复制， 内存依旧不释放的会晋升到老生代内存 执行老生代的缓存策略 2 内存占有休闲区的百分之五十以上的直接晋升

      回收优化
      1 并行回收， 回收时开启辅助线程一起回收
      2 增量标记 分段回收 三色标记法
      白色 未被标记的
      灰色 本身被标记
      黑色 本身和孩子都被标记
      标记清除法， 执行标记， 自身被引用标记为灰色， 子孙都被标记变成黑色， 当没有灰色节点的时候执行垃圾回收， 回收白色的节点

      写屏障
      当js代码更改对象指向的时候， 既黑色标记a指向白色标记c， 白色直接变成灰色， 之前的a 指向的黑色b的变量不会清除内存


      浏览器渲染原理
      1 解析html生成dom树
      2. 解析css生成css树
      3. 合并css树和dom树成render树
      4. 通过渲染树生成图层树
      5 每个图层生成渲染列表
      6 把渲染列表交给合成线程
      7 合成线程会图层分成图块， 并在光栅化线程生成位图
      8 合成线程发送绘制图块命令到浏览器线程
      9 浏览器根据DrawQuid消息生成页面，并显示到页面上面

      编译器 解析器
      解释器会一段一段编译代码为字节码，然后再由字节码转换为机器码，然后执行，遇到热区代码的时候，编辑器直接编译成机器码交给解释器执行

      微任务 宏任务 Node
      node 有多个任务队列，每个任务队列有最长执行时间，
      io回调队列  定时器队列  poll队列 check队列 io回到关闭队列
    </script>
  </body>

</html>